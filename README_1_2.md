# Project_exercise1

There is a entry_test.c file to test the project. 
In test, it reads a test.txt file to get some words and test the functions.
Functions are declared in entry_list.h, BK_tree.h and BK_List.h and defined in entry_list.c, BK_tree.c and BK_List.c

1. cd tests (go to directory tests)
2. Compile with command: make
3. Run : ./entry_test
<br>
<br>
<b>struct entry</b><br>
![entry](https://user-images.githubusercontent.com/61864130/141796761-f798c463-6127-4d9c-8a80-da6f30238160.jpg)
<br>
<b>struct entry_list</b><br>
![entry_list](https://user-images.githubusercontent.com/61864130/141796795-779aac62-7520-4feb-8f27-8e3c82aac92c.jpg)
<br>
Συγκεκριμένα, χρησιμοποιήθηκε μία έξτρα δομή η entry_list_node η οποία αντιπροσωπεύει ένα κόμβο λίστας και δέχεται ένα entry.
Η εισαγωγή μίας τέτοιας δομής είναι απαραίτητη καθώς ένα entry αν γίνει κόμβος λίστας και προσθέσουμε μέσα στη δομή του και ένα pointer σε άλλο entry, τότε αν αυτό το entry εισαχθεί σε 2 entry_list, θα χαθεί η σύνδεση των λιστών(πχ η αρχική λίστα και η λίστα με τα results στην lookup_entry_index). Οπότε εισάγουμε τον κόμβο λίστας στην υλοποίηση και επίσης συναρτήσεις όπως η get_first και get_next επιστρέφουν και παίρνουν όρισμα "κόμβο λίστας", προκειμένου η διάσχιση να γίνεται σε Ο(n) και όχι σε Ο(n^2)(καθώς αν παίρνουν entry θα πρέπει κάθε φορά να γίνεται αναζήτηση στη λίστα για να βρεθεί το entry και έπειτα να λάβουμε το επόμενο).<br>
Έξτρα συνάρτηση: entry_list_node_value -> επιστρέφει το entry ενός κόμβου λίστας.
<br>
<b>struct BK_tree</b><br>
![BK_tree](https://user-images.githubusercontent.com/61864130/141796806-70fdc372-8f2b-429b-81ca-5a75dd198dcf.jpg)
<br>

<br>


<b>DestroyFunc</b><br>
Δείκτης σε συναρτηση που χρησιμοποιείται για να καταστρέψει τα στοιχεία μία δομής, πιο συγκεκριμένα όταν δημιουργείται μία entry_list ή ένα BK_tree, μία τέτοια συνάρτηση παιρνιέται σαν όρισμα και αποθηκεύεται στην δομή και όταν έρθει η ώρα για την διαγραφή στοιχείου, τότε αν υπάρχει συνάρτηση τέτοια μες τη δομή και όχι NULL στη θέση της, τότε χρησιμοποιείται για να καταστρέψει το στοιχείο.<br>
Ο σχεδιασμός των struct με αυτό τον τρόπο είναι αναγκαίος καθώς πρέπει η κάθε δομή να είναι ενημερωμένη για το αν θα διαγράψει τα στοιχεία της ή όχι καθώς αν δεν γίνει με αυτό τον τρόπο μπορέι να έχουμε memory leaks ή double free() σενάρια.<br>
<br>

<b>BK_List</b><br>
Η δομή αυτή είναι υλοποιημένη στο .h αρχείο έτσι ώστε όπου χρησιμοποιείται, επειδή είναι βοηθητική δομή, να μπορούν τα υπόλοιπα αρχεία να έχουν πρόσβαση στα δεδομένα της χωρίς έξτρα συναρτήσεις.<br>
<br>
<br>




<b>Project 2</b><br>
<br>
Μεταγγλώττιση:<br>
Για τα tests:<br>
cd tests/<br>
make "όνομα εντολής"  (επιλέξτε ποιο αρχείο θέλετε να μεταγλωττίσετε, ή make all, make run για όλα μαζί)<br>
<br>
Για τον driver του sigmod:<br>
cd final-testdriver/<br>
make "Όνομα εντολής"
<br>
Χρησιμοποιήθηκαν test για το entrylist, BK_tree, ADTDeque, ADTSet, ADTMap, τα οποία μεταγλωττίζονται μέσα στο "cd tests/"
και για τον driver του sigmod έχει παραλλαχθεί τα Makefile ώστε να συμπεριλαμβάνει τα αρχεία μέσα στον κατάλλογο modules δηλαδή όλες τις υλοποιήσεις δομών και συναρτήσεων που χρησιμοποιούνται.
<br>
STRUCTS που χρησιμοποιήθηκαν:<br>
ADTMAP, ADTSet, ADTDeque, Hamming_tree, BK_tree, BK_List, entrylist, entry . (ADT = Abstract Data Type)<br>
<br>
Χρησιμοποιήθηκε το Set(με AVL δέντρο) και Map από το μάθημα των δομών δεδομένων, απλώς είναι αρχεία που έχουν δουλευτεί και παραλλαχτεί από εμάς κατά τη διάρκεια των εργασιών του μαθήματος αυτού(Εργασία 2-3, δομές δεδομένων 2021), επομένως δεν αποτελούν προϊόν αντιγραφής γιατί είναι και δικός μας κώδικας μέσα!<br>
Επειδή το map έχει γίνει παραλλαγή από open addressing σε separate chaining με set, σημαίνει ότι έπρεπε να παραλλάξουμε την exact match με την οποία θα γίνεται και η διάταξη μέσα στο set του κάθε κελιού του πίνακα κατακερματισμού, και αντί για true ή false να επιστρέφει < 0 αν η 1η λεξη είναι μικρότερη απ τη 2η, 0 αν είναι η ίδια λέξη και > 0 αν η 1η είναι μεγαλύτερη. Επομένως, αν οι διαφορές είναι 0 τότε είναι σαν να έχουμε true αλλίως αν είναι != 0 έχουμε false.<br>
Το ADTDeque έχει υλοποιηθεί εξ'ολοκλήρου από μας(Εργασία 2, δομές δεδομένων 2021) και αναπαριστά ένα Vector το οποίο όμως δύναται να προσθέσει στοιχεία και από μπροστά. Επιλέχθηκε αυτή η δομή αντί του Vector για λόγους αντιγραφής καθώς το Vector από το μάθημα των δομών δεδομένων δεν το έχουμε παραλλάξει ποτέ στο παρελθόν ούτε έχουμε αλλάξει ιδιαίτερα τον κώδικα του, σε αντίθεση με το Deque.<br>
<br>
<b>payload</b><br>
Με την υλοποίηση που έγινε, το payload δεν χρησιμοποίηθηκε πουθενά εν τέλει οπότε από set που κρατάνει τα ids των queries στα οποία περιέχεται το entry, τελικά το αφαιρέσαμε για να μην καθυστερεί το πρόγραμμα.<br>
<br>
<b>Deduplication στα entries των δομών</b><br>
Για τα διπλότυπα, στα δέντρα όταν γίνεται insert ένα καινούργιο entry του οποίου το word ήδη υπάρχει μέσα στο εκάστοτε δέντρο, τότε το δέντρο απλώς διατηρεί το παλιό entry και αγνοεί το καινούργιο. Για την exact_match, όμως, το map και το set σε περίπτωση duplications συγκατούν το καινούργιο στοιχείο και διαγράφουν το παλιό, επομένως πρώτα θα εφαρμόζουμε map_find(O(1)) για να δούμε αν υπάρχει ήδη ίδιο word μέσα στη δομή, και ύστερα αν δεν υπάρχει εισάγουμε το καινούργιο entry στη δομή.<br>
<b>Deduplication στις λέξεις των documents</b><br>
Για να αφαιρούμε τα διπλότυπα των κειμένων χρησιμοποίηθηκε μία δομή ADTMap έτσι ώστε να γίνεται αναζήτηση σε Ο(1) * για το αν έχει ελεχθεί παλιότερα η ίδια λέξη, και αν όχι τότε προστίθεται η καινούργια λέξη στο Map και ύστερα εκτελείται η lookup στις δομές.<br>
<br>
* (ουσιαστικά Ο(1) για την εύρεση του κελιού του πίνακα και Ο(logn) για την εύρεση της λέξης μέσα στο set του κελιού, απλώς αν έχουν χωριστεί καλά οι λέξεις μέσα στον πίνακα τότε το set του κάθε κελιού θα είναι μικρό άρα θα "αγγίζει" χρόνους Ο(1))<br>
<br>
<b>Σχεδιαστικές Επιλογές</b><br>
<br>
<b>StartQuery</b>:<br>
Η StartQuery δημιουργεί ένα Query και του αντιγράφει τα στοιχεία που περνάνε ως παράμετροι στην συνάρτηση. Η διαφορά με την αντίστοιχη συνάρτηση του αρχείου του sigmod είναι ότι αντί για συμβολοσειρά με λέξεις αποθηκεύει μέσα στο query μία entrylist και η κάθε λέξη εισάγεται μέσα σε ένα entry και αυτό εισάγεται μέσα στην λίστα. Έτσι το κάθε query έχει πρόσβαση απευθείας μέσα στα entries των δομών(hash table, BK_tree, Hamming_Tree) και μπορεί σε Ο(1) να λαμβάνει πληροφορίες σχετικά με την κάθε λέξη του, όπως αν η λέξη έγινε match με το document προς επεξεργασία, και με ποια απόσταση έγινε match<br>
(κάθε entry συγκρατεί την ελάχιστη απόσταση με την οποία έκανε match καθώς για παράδειγμα αν η ίδια λέξη κάνει match με 2 διαφορετικές λέξεις του document και dist_1 < dist_2, τότε στη σύγκιση:<br>
" dist <= matcdist " ισχύει το: " dist_1 < dist_2 < matchdist <=> dist_1 < matchdist " ,<br>
άρα η μικρότερη καλύπτει και τις 2 περιπτώσεις αφού αναφερόμαστε στην ίδια λέξη).<br>
<br>
Στη συνέχεια κάθε λέξη του query εισάγεται μέσα στην αντίστοιχη δομή που ορίζει το match_type,<br>
MT_EXACT_DIST: Για την εισαγωγή μέσα στο hash table πρώτα ελέγχεται αν έχει ξαναεισαχθεί η ίδια λέξη(Ο(1)), αν ναι τότε απλώς εισάγεται στο query το παλιό entry(O(1)), αλλιώς δημιουργείται ένα καινούργιο entry, εισάγεται στον πίνακα(Ο(1)) και ύστερα εισάγεται και στο query(Ο(1)).<br>
MT_EDIT_DIST: Για το ΒΚ_tree δημιουργείται ένα νέο entry για τη λέξη και εισάγεται στο δέντρο(O(logn)). Το BK_tree στην υλοποίηση του έχει σχεδιαστεί έτσι ώστε αν εισαχθεί ένα νέο entry του οποίου η λέξη όμως υπάρχει ήδη, τότε αγνοεί το καινούργιο και συγκρατεί το παλιό. Επίσης, μετά από κάθε εισαγωγή το δέντρο επιστρέφεται το entry που είτε εισήχθη είτε, σε περίπτωση ίδιας λέξης, τo παλιό entry που υπήρχε ήδη μέσα στο δέντρο. Με αυτόν τον τρόπο, ο κώδικάς έξω από την συνάρτηση ενημερώνεται για το entry που αφορά τη λέξη προς εισαγώγη και που υπάρχει μέσα στη δομή, οπότε και στο query εισάγεται το σωστό entry.<br>
MT_HAMMING_DIST: Για το Hamming_tree που στην ουσία είναι σύνολο από BK_trees, εφαρμόζεται η ίδια διαδικασία με την MT_EDIT_DIST, χρησιμοποιώντας τις κατάλληλες συναρτήσεις από το hamming.c που ενημερώνουν το κατάλληλο δέντρο ανάλογα το μέγεθος της λέξης.<br>
<br>
<b>EndQuery</b>:<br>
Η EndQuery απλώς διαγράφει το query μέσα από το set με τα queries.<br>
<br>
<b>MatchDocument</b>:<br>
Η MatchDocument δημιουργεί ένα νέο document και του εισάγει το id του. Ύστερα, εφαρμόζει deduplication για τις λέξεις του και παράλληλα για κάθε καινούργια λέξη, μέσω της map_find και lookup_entry_index βγάζει σε μία λίστα τα entries που έκαναν match. Πιο συγκεκριμένα:<br>
hash table: Μέσα στον πίνακα όλες οι λέξεις είναι διαφορετικές και για να κάνει match μία λέξη πρέπει να είναι η ίδια. Επομένως, το αποτέλεσμα μπορεί να είναι μόνο ένα και αν βρεθεί entry που έκανε match τότε ενημερώνει τις μεταβλητές του ότι:<br>
    το entry έκανε match(entry->matched = true) και,<br>
    το distance μεταξύ της λέξης του entry και του document είναι 0(entry->dist = 0).<br>
BK_tree: Η lookup μέσα στο BK_tree όταν κάνει match την λέξη ενός κόμβου τότε ελέγχει αν το συγκεκριμένο entry έχει ξαναγίνει match (entry->matched == true) έτσι ώστε να μην το ξαναεισάγει, αλλιώς αν είναι η πρώτη φορά τότε το δηλώνει ότι έγινε match μαζί με την τρέχουσα απόσταση που βρέθηκε και το προσθέτει στην λίστα αποτελεσμάτων. Αν όμως έχει εισαχθεί ήδη από προηγούμενη λέξη του document που έκαναν match τότε απλώς ελέγχει αν με την τρέχουσα λέξη έχουν μικρότερη απόσταση, αν ναι τότε ενημερώνει την απόστασή του με την καινούργια.<br>
<br>
Hamming_tree: Εκτελεί την lookup του BK_tree απλώς αρχικά βρίσκει το σωστό δέντρο για να την εκτελέσει σε αυτό.<br>
<br>
Στη συνέχεια αφού έχει δημιουργηθεί η τελική λίστα με τα αποτελέσματα, τότε για κάθε query ελέγχονται όλες του οι λέξεις αν έχουν γίνει matched και αν η απόσταση, με την οποία έκαναν match, είναι μικρότερη από το matchdist του query. Αν όλες οι λέξεις του περάσουν τον έλεγχο τότε το id του query εισάγεται προσωρινά μέσα σε ένα deque. Όταν, ελεχθούν ολα τα queries τότε αντιγράφεται ο ακριβής αριθμός των matched queries και δημιουργείται ο αντίστοιχος πίνακας του document για τα ids αυτά, τα οποία ύστερα αντιγράφονται από το deque εκεί.<br>
Τέλος, αποδεσμεύεται το deque και η λίστα αποτελεσμάτων, αφού πρώτα την διατρέξουμε για όλα entries και αρχικοποιήσουμε τις μεταβλητές τους για το επόμενο document προς εξέταση, και τέλος εισάγεται το document στο set με τα documents.<br>
<br>
<b>GetNextAvailRes</b>:<br>
Η συνάρτηση αυτή κάνει ότι και η συνάρτηση του sigmod απλώς παίρνει το 1ο στοιχείο του set με τα documents και ενημερώνει τις μεταβλητές. Τέλος, αφαιρεί το document από το set.